"""
Equ_models.
Модель данных отражающие модель уравнения, констант расчета, модель графического отражения уравнений
"""
from sympy import *

# В этой глобальной переменной будет храниться заданная для анализа функция.
# Сама функция может задаваться либо пользователем с консоли, либо быть переданной параметром
Function_us_def = '0'

# Константы проекта
SIGNS_named = {1: ('возрастает', 'f > 0'), -1: ('убывает', 'f < 0')}    # группы аналитических интервалов
EPSILON = 0.001         # Заданная погрешность определения корней (зависит от характера функций уравнения)
INF_cod = 8734          # код символа "бесконечность"
SCALE = 1.5             # комфортное для визуализации отношение вершины и максимума значения Y (масштабирование)
STEP = 0.01             # шаг аргумента для построения графика уравнения


# Создание структуры функции уравнения. Определение и возврат по запросу значений собственно функции, ее параметров
# Пример функции:  Function_us_def = '-12 * x**4 - 18 * x**3 + 5 * x**2 + 10 * x + 0'
#                  f_txt =           '-12x^4 - 18x^3 + 5x^2 + 10x',
#                  f_kf =            (-12, -18, 5, 10, 0)
# what_ret - что вернуть:
#         None  - значение функции
#         0     - текстовое написание функции и ее параметров (для алгебраического - коэффициенты полинома)
#         1 ... 10 (int) -  символьное (sympy) выражение производной w_ret-го порядка
# type_f - вид функции. None (по умолчанию) - алгебраическая функция.
#          Другие виды функций пока не рассматриваются и не реализованы
def f(x, what_ret=None, type_f=None):

    f_txt, f_kf = None, None
    if what_ret == 0:
        if not (type_f is None): return None, None
        f_txt = Function_us_def.replace('**', '^').replace('*', '').replace(' ', '').\
                                replace('+', ' + ').replace('-', ' - ').replace(' + 0', '')
        f_txt = f'{f_txt[:3].replace(" - ", "-")}{f_txt[3:]}'
        f_kf = Function_us_def.replace('*', '').replace('-', '+-').replace(' ', '').split('+')
        f_kf = tuple(map(float, [el.split('x')[0] for el in f_kf if el]))

    if x is None and what_ret is None: return None
    if what_ret is None:
        return eval(Function_us_def)
    if not what_ret: return f_txt, f_kf

    x = Symbol('x')
    f_y = eval(Function_us_def)
    return f_y.diff(x, what_ret)
